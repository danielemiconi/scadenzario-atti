rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isAdmin() {
      return isAuthenticated() && (
        request.auth.token.role == 'admin' ||
        (request.auth.token.email == 'daniele.miconi@iblegal.it') ||
        getUserData().role == 'admin'
      );
    }
    
    function getUserData() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
    }
    
    function isOwnerOrAssigned(deadline) {
      let userData = getUserData();
      return isAuthenticated() && (
        deadline.createdBy == request.auth.uid ||
        deadline.ownerInitials == userData.initials
      );
    }
    
    function hasValidDeadlineData() {
      let data = request.resource.data;
      return data.keys().hasAll(['monthYear', 'ownerInitials', 'matter', 'court', 
                                  'rg', 'actType', 'hearingDate', 'createdBy']) &&
             data.rg.matches('^[0-9]{1,6}/[0-9]{4}$') &&
             data.monthYear.matches('^[0-9]{4}-[0-9]{2}$');
    }
    
    function hasValidArchiveFields() {
      let data = request.resource.data;
      // When archiving, ensure proper archive fields are set
      return !data.keys().hasAny(['archived']) || 
             (data.archived == true && data.keys().hasAll(['archivedAt', 'archivedBy'])) ||
             (data.archived == false);
    }
    
    function hasValidDeleteFields() {
      let data = request.resource.data;
      // When soft deleting, ensure proper delete fields are set
      return !data.keys().hasAny(['deleted']) || 
             (data.deleted == true && data.keys().hasAll(['deletedAt', 'deletedBy'])) ||
             (data.deleted == false);
    }
    
    function isNotDuplicate() {
      // Check for duplicate based on court, rg, actType, hearingDate
      let data = request.resource.data;
      return !exists(/databases/$(database)/documents/deadlines/$(data.court + '_' + data.rg + '_' + data.actType + '_' + data.hearingDate));
    }
    
    // Users collection rules
    match /users/{userId} {
      allow read: if isAuthenticated();
      allow create: if request.auth.uid == userId && 
                       request.resource.data.keys().hasAll(['name', 'email', 'initials', 'role']);
      allow update: if request.auth.uid == userId || isAdmin();
      allow delete: if false; // No user deletion allowed
    }
    
    // Legend collection rules
    match /legend/{docId} {
      allow read: if isAuthenticated();
      allow create, update: if isAdmin() && 
                               request.resource.data.keys().hasAll(['initials', 'fullName', 'active']);
      allow delete: if isAdmin();
    }
    
    // Deadlines collection rules
    match /deadlines/{deadlineId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && 
                       hasValidDeadlineData() &&
                       hasValidArchiveFields() &&
                       hasValidDeleteFields() &&
                       request.resource.data.createdBy == request.auth.uid;
      allow update: if (isAdmin() || isOwnerOrAssigned(resource.data)) &&
                       hasValidDeadlineData() &&
                       hasValidArchiveFields() &&
                       hasValidDeleteFields();
      allow delete: if isAdmin(); // Only admin can hard delete - no additional validation needed
    }
    
    // Audit logs collection (write-only for system, read for admins)
    match /auditLogs/{logId} {
      allow read: if isAdmin();
      allow write: if false; // Only Cloud Functions can write
    }
    
    // Notifications collection (for tracking sent notifications)
    match /notifications/{notificationId} {
      allow read: if isAdmin() || 
                     (isAuthenticated() && resource.data.userId == request.auth.uid);
      allow write: if false; // Only Cloud Functions can write
    }
  }
}